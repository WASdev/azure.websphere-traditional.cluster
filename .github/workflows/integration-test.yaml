name: integration-test
on:
  workflow_dispatch:
    inputs:
      selectLoadBalancer:
        description: 'Select a load balancer'
        required: true
        default: 'ihs'
        type: choice
        options:
        - 'ihs'
        - 'appgw'
        - 'no'
      databaseType:
        description: 'Database connection'
        required: true
        default: 'db2'
        type: choice
        options:
        - db2
        - oracle
        - sqlserver
        - postgres
        - none
      deleteAzureResources:
        description: 'Delete Azure resources at the end'
        required: true
        type: boolean
        default: true
  # Allows you to run this workflow using GitHub APIs
  # PERSONAL_ACCESS_TOKEN=<GITHUB_PERSONAL_ACCESS_TOKEN>
  # REPO_NAME=WASdev/azure.websphere-traditional.cluster
  # Select a load balancer, enable database connection and delete Azure resources at the end. Specify the desired load balancer type (ihs, appgw, no) for parameter "selectLoadBalancer". Specify the desired database type (db2, oracle, sqlserver, postgres) for parameter "databaseType".
  # curl --verbose -XPOST -u "WASdev:${PERSONAL_ACCESS_TOKEN}" -H "Accept: application/vnd.github.everest-preview+json" -H "Content-Type: application/json" https://api.github.com/repos/${REPO_NAME}/actions/workflows/integration-test.yaml/dispatches --data '{"ref": "main", "inputs":{"selectLoadBalancer": "ihs", "databaseType": "db2"}}'
  # Select a load balancer, enable database connection and keep Azure resources at the end. Specify the desired load balancer type (ihs, appgw, no) for parameter "selectLoadBalancer". Specify the desired database type (db2, oracle, sqlserver, postgres) for parameter "databaseType".
  # curl --verbose -XPOST -u "WASdev:${PERSONAL_ACCESS_TOKEN}" -H "Accept: application/vnd.github.everest-preview+json" -H "Content-Type: application/json" https://api.github.com/repos/${REPO_NAME}/actions/workflows/integration-test.yaml/dispatches --data '{"ref": "main", "inputs":{"selectLoadBalancer": "ihs", "databaseType": "db2", "deleteAzureResources": "false"}}'
  # Select a load balancer, disable database connection and delete Azure resources at the end. Specify the desired load balancer type (ihs, appgw, no) for parameter "selectLoadBalancer".
  # curl --verbose -XPOST -u "WASdev:${PERSONAL_ACCESS_TOKEN}" -H "Accept: application/vnd.github.everest-preview+json" -H "Content-Type: application/json" https://api.github.com/repos/${REPO_NAME}/actions/workflows/integration-test.yaml/dispatches --data '{"ref": "main", "inputs":{"selectLoadBalancer": "ihs", "databaseType": "none"}}'
  # Select a load balancer, disable database connection and keep Azure resources at the end. Specify the desired load balancer type (ihs, appgw, no) for parameter "selectLoadBalancer".
  # curl --verbose -XPOST -u "WASdev:${PERSONAL_ACCESS_TOKEN}" -H "Accept: application/vnd.github.everest-preview+json" -H "Content-Type: application/json" https://api.github.com/repos/${REPO_NAME}/actions/workflows/integration-test.yaml/dispatches --data '{"ref": "main", "inputs":{"selectLoadBalancer": "ihs", "databaseType": "none", "deleteAzureResources": "false"}}'
  repository_dispatch:
    types: [integration-test]
  # sample request
  # PERSONAL_ACCESS_TOKEN=<GITHUB_PERSONAL_ACCESS_TOKEN>
  # REPO_NAME=WASdev/azure.websphere-traditional.cluster
  # Select a load balancer, enable database connection and delete Azure resources at the end. Specify the desired load balancer type (ihs, appgw, no) for parameter "selectLoadBalancer". Specify the desired database type (db2, oracle, sqlserver, postgres) for parameter "databaseType".
  # curl --verbose -X POST https://api.github.com/repos/${REPO_NAME}/dispatches -H "Accept: application/vnd.github.everest-preview+json" -H "Authorization: token ${PERSONAL_ACCESS_TOKEN}" --data '{"event_type": "integration-test", "client_payload": {"selectLoadBalancer": "ihs", "databaseType": "db2", "deleteAzureResources": true}}'
  # Select a load balancer, enable database connection and keep Azure resources at the end. Specify the desired load balancer type (ihs, appgw, no) for parameter "selectLoadBalancer". Specify the desired database type (db2, oracle, sqlserver, postgres) for parameter "databaseType".
  # curl --verbose -X POST https://api.github.com/repos/${REPO_NAME}/dispatches -H "Accept: application/vnd.github.everest-preview+json" -H "Authorization: token ${PERSONAL_ACCESS_TOKEN}" --data '{"event_type": "integration-test", "client_payload": {"selectLoadBalancer": "ihs", "databaseType": "db2", "deleteAzureResources": false}}'
  # Select a load balancer, disable database connection and delete Azure resources at the end. Specify the desired load balancer type (ihs, appgw, no) for parameter "selectLoadBalancer".
  # curl --verbose -X POST https://api.github.com/repos/${REPO_NAME}/dispatches -H "Accept: application/vnd.github.everest-preview+json" -H "Authorization: token ${PERSONAL_ACCESS_TOKEN}" --data '{"event_type": "integration-test", "client_payload": {"selectLoadBalancer": "ihs", "databaseType": "none", "deleteAzureResources": true}}'
  # Select a load balancer, disable database connection and keep Azure resources at the end. Specify the desired load balancer type (ihs, appgw, no) for parameter "selectLoadBalancer".
  # curl --verbose -X POST https://api.github.com/repos/${REPO_NAME}/dispatches -H "Accept: application/vnd.github.everest-preview+json" -H "Authorization: token ${PERSONAL_ACCESS_TOKEN}" --data '{"event_type": "integration-test", "client_payload": {"selectLoadBalancer": "ihs", "databaseType": "none", "deleteAzureResources": false}}'
env:
  repoName: "azure.websphere-traditional.cluster"
  azureCredentials: ${{ secrets.AZURE_CREDENTIALS }}
  userName: ${{ secrets.USER_NAME }}
  msTeamsWebhook: ${{ secrets.MSTEAMS_WEBHOOK }}
  vmAdminId: ${{ secrets.VM_ADMIN_ID }}
  vmAdminPassword: ${{ secrets.VM_ADMIN_PASSWORD }}
  dbInstanceName: db${{ github.run_id }}${{ github.run_number }}
  dbPassword: ${{ secrets.DATABASE_PASSWORD }}
  testResourceGroup: twasClusterTestRG${{ github.run_id }}${{ github.run_number }}
  testDeploymentName: twasClusterTestDeployment${{ github.run_id }}${{ github.run_number }}
  location: eastus
  scriptLocation: https://raw.githubusercontent.com/${{ secrets.USER_NAME }}/azure.websphere-traditional.cluster/$GITHUB_REF_NAME/test/
jobs:
  integration-test:
    runs-on: ubuntu-latest
    steps:
      - name: Get versions of external dependencies
        run: |
          curl -Lo external-deps-versions.properties https://raw.githubusercontent.com/Azure/azure-javaee-iaas/main/external-deps-versions.properties
          source external-deps-versions.properties
          echo "azCliVersion=${AZ_CLI_VERSION}" >> $GITHUB_ENV
          echo "bicepVersion=${BICEP_VERSION}" >> $GITHUB_ENV
          echo "refArmttk=${ARM_TTK_REFERENCE}" >> $GITHUB_ENV
          echo "refJavaee=${AZURE_JAVAEE_IAAS_REFERENCE}" >> $GITHUB_ENV
      - name: Set up JDK 1.8
        uses: actions/setup-java@v1
        with:
          java-version: 1.8
      - name: Set up bicep
        run: |
          curl -Lo bicep https://github.com/Azure/bicep/releases/download/${{ env.bicepVersion }}/bicep-linux-x64
          chmod +x ./bicep
          sudo mv ./bicep /usr/local/bin/bicep
          bicep --version
      - name: Checkout azure-javaee-iaas
        uses: actions/checkout@v2
        with:
          repository: Azure/azure-javaee-iaas
          path: azure-javaee-iaas
          ref: ${{ env.refJavaee }}
      - name: Checkout arm-ttk
        uses: actions/checkout@v2
        with:
          repository: Azure/arm-ttk
          path: arm-ttk
          ref: ${{ env.refArmttk }}
      - name: Checkout ${{ env.repoName }}
        uses: actions/checkout@v2
        with:
          path: ${{ env.repoName }}
          ref: ${{ github.event.inputs.ref }}
      - name: Build azure-javaee-iaas
        run: mvn -DskipTests clean install --file azure-javaee-iaas/pom.xml
      - uses: azure/login@v1
        id: azure-login
        with:
          creds: ${{ env.azureCredentials }}
      - name: Deploy an IBM DB2 server on Azure VM
        if: ${{ inputs.databaseType == 'db2' || github.event.client_payload.databaseType == 'db2' }}
        run: |
          az group create -n ${{ env.testResourceGroup }} -l ${{ env.location }}
          az vm create \
            --resource-group ${{ env.testResourceGroup }} --name ${{ env.dbInstanceName }} \
            --image "Canonical:UbuntuServer:18.04-LTS:latest" \
            --admin-username azureuser --generate-ssh-keys \
            --nsg-rule NONE --enable-agent true \
            --vnet-name ${{ env.dbInstanceName }}VNET --enable-auto-update false \
            --tags SkipASMAzSecPack=true SkipNRMSCorp=true SkipNRMSDatabricks=true SkipNRMSDB=true SkipNRMSHigh=true SkipNRMSMedium=true SkipNRMSRDPSSH=true SkipNRMSSAW=true SkipNRMSMgmt=true
          az vm open-port -g ${{ env.testResourceGroup }} -n ${{ env.dbInstanceName }} --port 50000 --priority 100
          az vm extension set --name CustomScript \
            --extension-instance-name install-db2-in-docker \
            --resource-group ${{ env.testResourceGroup }} --vm-name ${{ env.dbInstanceName }} \
            --publisher Microsoft.Azure.Extensions --version 2.0 \
            --settings "{\"fileUris\": [\"${{ env.scriptLocation }}install-db2.sh\"]}" \
            --protected-settings "{\"commandToExecute\":\"bash install-db2.sh ${{ env.dbPassword }}\"}"
      - name: Deploy an Oracle database server on Azure VM
        if: ${{ inputs.databaseType == 'oracle' || github.event.client_payload.databaseType == 'oracle' }}
        run: |
          az group create -n ${{ env.testResourceGroup }} -l ${{ env.location }}
          az vm create \
            --resource-group ${{ env.testResourceGroup }} --name ${{ env.dbInstanceName }} \
            --image Oracle:oracle-database-19-3:oracle-database-19-0904:latest --size Standard_DS2_v2 \
            --admin-username azureuser --generate-ssh-keys \
            --nsg-rule NONE --enable-agent true \
            --vnet-name ${{ env.dbInstanceName }}VNET --enable-auto-update false \
            --tags SkipASMAzSecPack=true SkipNRMSCorp=true SkipNRMSDatabricks=true SkipNRMSDB=true SkipNRMSHigh=true SkipNRMSMedium=true SkipNRMSRDPSSH=true SkipNRMSSAW=true SkipNRMSMgmt=true
          az vm disk attach --name oradata01 --new --resource-group ${{ env.testResourceGroup }} --vm-name ${{ env.dbInstanceName }} --size-gb 64 --sku StandardSSD_LRS
          az vm open-port -g ${{ env.testResourceGroup }} -n ${{ env.dbInstanceName }} --port 1521,5502 --priority 100
          az vm extension set --name CustomScript \
            --extension-instance-name install-oracle \
            --resource-group ${{ env.testResourceGroup }} --vm-name ${{ env.dbInstanceName }} \
            --publisher Microsoft.Azure.Extensions --version 2.0 \
            --settings "{\"fileUris\": [\"${{ env.scriptLocation }}install-oracle-main.sh\", \"${{ env.scriptLocation }}install-oracle.sh\"]}" \
            --protected-settings "{\"commandToExecute\":\"bash install-oracle-main.sh ${{ env.dbPassword }}\"}"
      - name: Deploy an instance of Azure SQL Database
        if: ${{ inputs.databaseType == 'sqlserver' || github.event.client_payload.databaseType == 'sqlserver' }}
        run: |
          az group create -n ${{ env.testResourceGroup }} -l ${{ env.location }}
          az sql server create \
            --resource-group ${{ env.testResourceGroup }} --name ${{ env.dbInstanceName }} \
            --admin-user testuser --admin-password ${{ env.dbPassword }} \
            --location ${{ env.location }}
          host=$(az sql server show \
            --resource-group ${{ env.testResourceGroup }} --name ${{ env.dbInstanceName }} \
            --query "fullyQualifiedDomainName" -o tsv)
          echo "sqlserverHost=${host}" >> $GITHUB_ENV
          # Allow Azure services to access
          az sql server firewall-rule create \
            --resource-group ${{ env.testResourceGroup }} --server ${{ env.dbInstanceName }} \
            --name "AllowAllAzureIps" --start-ip-address 0.0.0.0 --end-ip-address 0.0.0.0
          az sql db create --resource-group ${{ env.testResourceGroup }} --server ${{ env.dbInstanceName }} --name testdb
      - name: Deploy an instance of Azure Database for PostgreSQL
        if: ${{ inputs.databaseType == 'postgres' || github.event.client_payload.databaseType == 'postgres' }}
        run: |
          az group create -n ${{ env.testResourceGroup }} -l ${{ env.location }}
          az postgres server create \
            --resource-group ${{ env.testResourceGroup }} --name ${{ env.dbInstanceName }} \
            --admin-user testuser --admin-password ${{ env.dbPassword }} \
            --location ${{ env.location }}
          host=$(az postgres server show \
            --resource-group ${{ env.testResourceGroup }} --name ${{ env.dbInstanceName }} \
            --query "fullyQualifiedDomainName" -o tsv)
          echo "postgresqlHost=${host}" >> $GITHUB_ENV
          # Allow Azure services to access
          az postgres server firewall-rule create \
            --resource-group ${{ env.testResourceGroup }} --server ${{ env.dbInstanceName }} \
            --name "AllowAllAzureIps" --start-ip-address 0.0.0.0 --end-ip-address 0.0.0.0
          az postgres db create --resource-group ${{ env.testResourceGroup }} --server ${{ env.dbInstanceName }} --name testdb
      - name: Build ${{ env.repoName }}
        run: |
          enableDB=false
          databaseType=db2
          dsConnectionURL=jdbc:db2://contoso.db2.database:50000/sample
          dbUser=contosoDbUser
          if ${{ inputs.databaseType == 'db2' || github.event.client_payload.databaseType == 'db2' }}; then
            enableDB=true
            databaseType=db2
            publicIp=$(az vm show -g ${{ env.testResourceGroup }} -n ${{ env.dbInstanceName }} -d --query publicIps -o tsv)
            dsConnectionURL=jdbc:db2://${publicIp}:50000/sample
            dbUser=db2inst1
          elif ${{ inputs.databaseType == 'oracle' || github.event.client_payload.databaseType == 'oracle' }}; then
            enableDB=true
            databaseType=oracle
            publicIp=$(az vm show -g ${{ env.testResourceGroup }} -n ${{ env.dbInstanceName }} -d --query publicIps -o tsv)
            dsConnectionURL=jdbc:oracle:thin:@${publicIp}:1521/oratest1
            dbUser=testuser
          elif ${{ inputs.databaseType == 'sqlserver' || github.event.client_payload.databaseType == 'sqlserver' }}; then
            enableDB=true
            databaseType=sqlserver
            dsConnectionURL="jdbc:sqlserver://${{ env.sqlserverHost }}:1433;database=testdb"
            dbUser=testuser@${{ env.dbInstanceName }}
          elif ${{ inputs.databaseType == 'postgres' || github.event.client_payload.databaseType == 'postgres' }}; then
            enableDB=true
            databaseType=postgres
            dsConnectionURL="jdbc:postgresql://${{ env.postgresqlHost }}:5432/testdb"
            dbUser=testuser@${{ env.dbInstanceName }}
          fi
          selectLoadBalancer=no
          if ${{ inputs.selectLoadBalancer == 'ihs' || github.event.client_payload.selectLoadBalancer == 'ihs' }}; then
            selectLoadBalancer=ihs
          elif ${{ inputs.selectLoadBalancer == 'appgw' || github.event.client_payload.selectLoadBalancer == 'appgw' }}; then
            selectLoadBalancer=appgw
          fi
          echo "selectLoadBalancer=${selectLoadBalancer}" >> $GITHUB_ENV
          cd ${{ env.repoName }}
          mvn -Dgit.repo=${{ env.userName }} -Dgit.tag=$GITHUB_REF_NAME -DuseTrial=true \
            -DnumberOfNodes=3 -DvmSize=Standard_D2_v3 -DdmgrVMPrefix=dmgr -DmanagedVMPrefix=managed -DdnsLabelPrefix=wasndcluster \
            -DadminUsername=${{ env.vmAdminId }} -DadminPasswordOrKey=${{ env.vmAdminPassword }} \
            -DauthenticationType=password -DwasUsername=${{ env.vmAdminId }} -DwasPassword=${{ env.vmAdminPassword }} \
            -DselectLoadBalancer=${selectLoadBalancer} -DenableCookieBasedAffinity=true -DihsVmSize=Standard_D2_v3 -DihsVMPrefix=ihs -DihsDnsLabelPrefix=ihs \
            -DihsUnixUsername=${{ env.vmAdminId }} -DihsUnixPasswordOrKey=${{ env.vmAdminPassword }} \
            -DihsAuthenticationType=password -DihsAdminUsername=${{ env.vmAdminId }} -DihsAdminPassword=${{ env.vmAdminPassword }} \
            -DenableDB=${enableDB} -DdatabaseType=${databaseType} -DjdbcDataSourceJNDIName=jdbc/WebSphereCafeDB -DdsConnectionURL=${dsConnectionURL} -DdbUser=${dbUser} -DdbPassword=${{ env.dbPassword }} \
            -Dtest.args="-Test All" -Pbicep -Passembly -Ptemplate-validation-tests clean install
      - name: Deploy a twas-cluster on Azure VMs
        run: |
          cd ${{ env.repoName }}/target/cli
          chmod a+x deploy.azcli
          ./deploy.azcli -n ${{ env.testDeploymentName }} -g ${{ env.testResourceGroup }} -l ${{ env.location }}
      - name: Verify the deployment
        run: |
          outputs=$(az deployment group show -n ${{ env.testDeploymentName }} -g ${{ env.testResourceGroup }} --query 'properties.outputs')
          adminSecuredConsole=$(echo $outputs | jq -r '.adminSecuredConsole.value')
          curl $adminSecuredConsole -k
          if [[ $? -ne 0 ]]; then
            echo "Failed to access ${adminSecuredConsole}."
            exit 1
          fi
          ihsConsole=$(echo $outputs | jq -r '.ihsConsole.value')
          if [[ $selectLoadBalancer == "ihs" ]]; then
            curl $ihsConsole
            if [[ $? -ne 0 ]]; then
              echo "Failed to access ${ihsConsole}."
              exit 1
            fi
          else
            if [[ $ihsConsole != "N/A" ]]; then
              echo "ihsConsole is ${ihsConsole}, but it should be N/A as IHS is not enabled."
              exit 1
            fi
          fi
          appGatewayHttpURL=$(echo $outputs | jq -r '.appGatewayHttpURL.value')
          appGatewayHttpsURL=$(echo $outputs | jq -r '.appGatewayHttpsURL.value')
          if [[ $selectLoadBalancer == "appgw" ]]; then
            curl $appGatewayHttpURL
            if [[ $? -ne 0 ]]; then
              echo "Failed to access ${appGatewayHttpURL}."
              exit 1
            fi
            curl $appGatewayHttpsURL -k
            if [[ $? -ne 0 ]]; then
              echo "Failed to access ${appGatewayHttpsURL}."
              exit 1
            fi
          else
            if [[ $appGatewayHttpURL != "N/A" ]]; then
              echo "appGatewayHttpURL is ${appGatewayHttpURL}, but it should be N/A as application gateway is not enabled."
              exit 1
            fi
            if [[ $appGatewayHttpsURL != "N/A" ]]; then
              echo "appGatewayHttpsURL is ${appGatewayHttpsURL}, but it should be N/A as application gateway is not enabled."
              exit 1
            fi
          fi
      - name: Delete all Azure resources
        id: delete-resources-in-group
        if: ${{ (github.event_name == 'workflow_dispatch' && inputs.deleteAzureResources) || (github.event_name == 'repository_dispatch' && github.event.client_payload.deleteAzureResources) }}
        uses: azure/CLI@v1
        with:
          azcliversion: ${{ env.azCliVersion }}
          inlineScript: |
            az group delete -n ${{ env.testResourceGroup }} --yes
      - name: Generate artifact file name and path
        id: artifact_file
        run: |
          version=$(awk '/<version>[^<]+<\/version>/{gsub(/<version>|<\/version>/,"",$1);print $1;exit;}' ${{ env.repoName }}/pom.xml)
          artifactName=${{ env.repoName }}-$version-arm-assembly
          unzip ${{ env.repoName }}/target/$artifactName.zip -d ${{ env.repoName }}/target/$artifactName
          echo "##[set-output name=artifactName;]${artifactName}"
          echo "##[set-output name=artifactPath;]${{ env.repoName }}/target/$artifactName"
      - name: Archive ${{ env.repoName }} template
        uses: actions/upload-artifact@v1
        if: success()
        with:
          name: ${{steps.artifact_file.outputs.artifactName}}
          path: ${{steps.artifact_file.outputs.artifactPath}}
  notification:
    needs: integration-test
    if: always()
    runs-on: ubuntu-latest
    steps:
      - name: Output inputs from workflow_dispatch
        run: echo "${{ toJSON(github.event.inputs) }}"
      - name: Output client_payload from repository_dispatch
        run: echo "${{ toJSON(github.event.client_payload) }}"
      - name: Send notification
        if: ${{ env.msTeamsWebhook != 'NA' }}
        run: |
            workflowJobs=$(curl -H "Accept: application/vnd.github.v3+json" https://api.github.com/repos/${{ env.userName }}/${{ env.repoName }}/actions/runs/${{ github.run_id }}/jobs)
            successIntegrationTestJob=$(echo $workflowJobs | jq '.jobs | map(select(.name=="integration-test" and .conclusion=="success")) | length')
            if (($successIntegrationTestJob == 0));then
                echo "Job integration-test failed, send notification to Teams"
                curl ${{ env.msTeamsWebhook }} \
                -H 'Content-Type: application/json' \
                --data-binary @- << EOF
                {
                "@context":"http://schema.org/extensions",
                "@type":"MessageCard",
                "text":"Workflow integration-test of repo ${{ env.repoName }} failed, please take a look at: https://github.com/${{ env.userName }}/${{ env.repoName }}/actions/runs/${{ github.run_id }}"
                }
            EOF
            else
                echo "Job integration-test succeeded."
            fi
